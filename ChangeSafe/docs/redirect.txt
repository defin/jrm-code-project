Idea for how to support redirection.

There are 3 reasons to want to redirect:

  1.  The current server is currenty too busy to handle the request.

  2.  The current server is inappropriate or unable to handle the
      request.  (e.g., we wish to perform a long read-only transaction
      but we have directed the request at the read-write server while
      there are several read-only servers available.)

  3.  The request involves two transactions --- a short read-write
      transaction, and a long read-only transaction.  We wish to
      perform the short transaction on the read-write server, but to
      hand off the long transaction to the read-only server.

The mechanims for handling these three situations is basically the
same, but there are some subtle differences.  Let me illustrate a few
scenarios.  In all these scenarios, there is assumed to be a `primary'
ChangeSafe server that is the `default' server.  It is assumed that
the ChangeSafe client is aware only of the default server.

I am further assuming that the `primary' server is able to use the
database in read-write mode, but that the `secondary' servers are
restricted to `read-only' use.



Scenario 1.  The user wants to perform a cset_close, but the sole
read-write server is in the middle of performing a different
cset_close.  In this case, we wish to inform the user that the server
is busy and there will be a delay.  We may wish to provide some
mechanism for the user to indicate that he would rather forgo the
operation than wait.  (Provided that the user doesn't decide to give
up, we would want to enqueue the request to ensure fairness.  We may
wish to give the user some idea of how long he might have to wait, but
that may be too difficult.)

This scenario does not actually involve redirection, but is germane to
the discussion because all scenarions degenarate into this one when
there is only one server, or when there are several, but they are so
heavily loaded that a wait is inevitable.



Scenario 2.  The user wants to see the help info, but the primary
server is in the middle of a long transaction.  In this case,
(assuming that there are other servers), we wish to instruct the
client to retry the *same* operation on a different server.  The
client would receive a list of alternate servers and enter a loop
where it would attempt to perform the operation by submitting the same
request to one of the alternate servers.  If an alternate is
unavailable (down) or busy, the next one on the list would be tried.

The situation may arise where *none* of the servers in the list can
handle the request (all are busy or down).  If this occurs, we must
go back to one of the busy ones and wait.  This implies some sort of
handshaking in the redirect protocol,  (Client:  Hey, I want to see
the help text.  Server:  Ask one of these guys, I'm busy.  Client:  I
already tried that, no one is awake.  Server:  Ok, I'll get to you
when I can.), or some sort of priority flag in the command (Client:
Hey, I want to see the help text.  Server:  Ask one of these guys, I'm
busy. ...time passes...  Client:  Hey, I want to see the help text and
you are not allowed to blow me off.  Server:  Ok, get in line.)

In a situation where there is more than one read-write server, the
primary server would have to send back an alternative list that was
appropriate for the command, i.e., a list of read-write servers for a
read-write command, or a list of read-only servers for a read-only
command.  Since this list could be in error, some sort of protocol is
needed to indicate inappropriateness (client:  Hey, the primary server
told me you could handle my changes.  Secondary server:  He's nuts, I
don't do that.  Client:  oh well, I'll ask someone else.)

If the primary server permuted its redirect list with each request, it
would help ensure a more fair scheduling.


Scenario 3.  The user wants to create a workspace.  He can do this in
two phases.  The first is a short read-write transaction to the
database where the workspace data is created and a timestamp for the
workspace is noted.  The second is a long read-only transaction where
the files are extracted from the server and placed on the servers disk
(much like ws_regenerate).  In this case, we want to instruct the
client to perform a *different* transaction (presumably on a different
server).  This second transaction *may* need to include some state
information generated by the first transaction (logically speaking, I
actually think it doesn't!  Consider that the second transaction must
be idempotent if it is to be considered a different transaction.  Thus
the state of the system need not be known a-priori to the second
transaction.)

-------
Proposed Redirect Protocol.

The deferral protocol is designed to be stateless for the server.  All
state is kept in the client.

All client requests have a priority flag that indicates that they have
`been around the block' looking for service.  A request containing
that flag cannot be deferred if it can be handled, but it may be
queued.  A request *not* containing the flag may be deferred.  A
request that cannot be handled by this server may be deferred.

When a server defers an operation, it can do it as follows:

1.  A no-service deferral indicates that the server is unable to
    handle the client request (e.g. a read-write request on a
    read-only server).  The deferral should contain a text string
    indicating the reason why the request was deferred.  An optional
    list of alternate servers that may be able to handle the request
    may be given.

2.  A busy deferral indicates that the server has too much work to do
    to handle the request.  The deferral should contain a text string
    indicating the reason why the request was deferred.  It can pass
    two optional fields.  The first is a list of alternative servers
    that should be tried, the second is an estimate of how much work
    is currently queued on the server.  (Note:  It is assumed that the
    primary server would know a list of secondary ones, but it is not
    necessary that the primary know all the secondaries, or that the
    secondaries not provide more alternatives.)  The alternatives
    should be URL's of the same form as the CHANGESAFE_SERVER_URI
    argument to the client.

3.  A continuation deferral indicates that first transaction of a two
    transaction operation has completed successfully.  The deferral
    should contain the next command to be executed.  It may have an
    optional field indicating a list of servers that should be tried
    to handle the optional command.

The client manages its state thus:

1.  There is a `priority flag' that initially begins in an `off'
    state.

2.  There is a list of `servers to try' that starts with at least one
    element, the primary server.

3.  There is a list of `servers tried' that starts empty.
   
4.  There is a list of `dead servers' that starts empty.

The client performs this loop:

   If the `servers to try' list is empty and the `priority flag' is
   `on', the client reports an error to the user.  (This indicates
   that no servers could handle the request.)

   If the `servers to try' list is empty and the `priority flag' is
   `off', the priority flag is turned `on', and the list of servers in
   the `servers tried' list is placed on the `servers to try' list.
   (This is the appropriate place to ask the user if he wants to wait.
    If he decides not to, we can simply exit.)

   A `server to try' is selected and removed from the `servers to try'
   list.  The priority flag is passed as part of the request.

   If the server cannot be contacted, we place it on the `dead
   servers' list and go to the top of the loop.

   If the server handles the request, we report status and exit.  Note
   that the server *MUST NOT* defer the request if it is a `priority'
   request and the server can process it.  (This ensures that someone
   will eventually handle the request.)  The server may return a
   `continuation deferral' after processing a `priority' request.

   If the server deferrs for any reason, it may pass us some alternate
   hosts.  If it does, we take any host that we don't already know
   about (on one of the server lists) and place it on the `server to
   try' list.  (The dead servers list ensures that we don't keep
   trying to contact hosts known to be down).

   If the server performs a `continuation' deferral, we reset the
   priority flag to `off' and move the contents of the `servers tried'
   list to the `servers to try'.  The `continuation' deferral will
   contain a new command.  We go to the top of the loop with the new
   command.

   If the server performs a `busy' deferral, we place the server on
   the `servers tried' list and go to the top of the loop.
